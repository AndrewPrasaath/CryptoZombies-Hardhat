{
  "language": "Solidity",
  "sources": {
    "contracts/CryptoZombies.sol": {
      "content": "pragma solidity >=0.5.0 <0.9.0;\n\nimport \"./zombieOwnership.sol\";\n\ncontract CryptoZombies is ZombieOwnership {}\n"
    },
    "contracts/erc721.sol": {
      "content": "pragma solidity >=0.5.0 <0.6.0;\n\ncontract ERC721 {\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _tokenId\n    );\n    event Approval(\n        address indexed _owner,\n        address indexed _approved,\n        uint256 indexed _tokenId\n    );\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    function approve(address _approved, uint256 _tokenId) external payable;\n}\n"
    },
    "contracts/ownable.sol": {
      "content": "pragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/safemath.sol": {
      "content": "pragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title SafeMath32\n * @dev SafeMath library implemented for uint32\n */\nlibrary SafeMath32 {\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n        if (a == 0) {\n            return 0;\n        }\n        uint32 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint32 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\n        uint32 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title SafeMath16\n * @dev SafeMath library implemented for uint16\n */\nlibrary SafeMath16 {\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n        if (a == 0) {\n            return 0;\n        }\n        uint16 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint16 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\n        uint16 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n"
    },
    "contracts/zombieattack.sol": {
      "content": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./zombiehelper.sol\";\n\ncontract ZombieAttack is ZombieHelper {\n    uint randNonce = 0;\n    uint attackVictoryProbability = 70;\n\n    function randMod(uint _modulus) internal returns (uint) {\n        randNonce = randNonce.add(1);\n        return\n            uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) %\n            _modulus;\n    }\n\n    function attack(\n        uint _zombieId,\n        uint _targetId\n    ) external onlyOwnerOf(_zombieId) {\n        Zombie storage myZombie = zombies[_zombieId];\n        Zombie storage enemyZombie = zombies[_targetId];\n        uint rand = randMod(100);\n        if (rand <= attackVictoryProbability) {\n            myZombie.winCount = myZombie.winCount.add(1);\n            myZombie.level = myZombie.level.add(1);\n            enemyZombie.lossCount = enemyZombie.lossCount.add(1);\n            feedAndMultiply(_zombieId, enemyZombie.dna, \"zombie\");\n        } else {\n            myZombie.lossCount = myZombie.lossCount.add(1);\n            enemyZombie.winCount = enemyZombie.winCount.add(1);\n            _triggerCooldown(myZombie);\n        }\n    }\n}\n"
    },
    "contracts/zombiefactory.sol": {
      "content": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./ownable.sol\";\nimport \"./safemath.sol\";\n\ncontract ZombieFactory is Ownable {\n    using SafeMath for uint256;\n    using SafeMath32 for uint32;\n    using SafeMath16 for uint16;\n\n    event NewZombie(uint zombieId, string name, uint dna);\n\n    uint dnaDigits = 16;\n    uint dnaModulus = 10 ** dnaDigits;\n    uint cooldownTime = 1 days;\n\n    struct Zombie {\n        string name;\n        uint dna;\n        uint32 level;\n        uint32 readyTime;\n        uint16 winCount;\n        uint16 lossCount;\n    }\n\n    Zombie[] public zombies;\n\n    mapping(uint => address) public zombieToOwner;\n    mapping(address => uint) ownerZombieCount;\n\n    function _createZombie(string memory _name, uint _dna) internal {\n        uint id = zombies.push(\n            Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)\n        ) - 1;\n        zombieToOwner[id] = msg.sender;\n        ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].add(1);\n        emit NewZombie(id, _name, _dna);\n    }\n\n    function _generateRandomDna(\n        string memory _str\n    ) private view returns (uint) {\n        uint rand = uint(keccak256(abi.encodePacked(_str)));\n        return rand % dnaModulus;\n    }\n\n    function createRandomZombie(string memory _name) public {\n        require(ownerZombieCount[msg.sender] == 0);\n        uint randDna = _generateRandomDna(_name);\n        randDna = randDna - (randDna % 100);\n        _createZombie(_name, randDna);\n    }\n}\n"
    },
    "contracts/zombiefeeding.sol": {
      "content": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./zombiefactory.sol\";\n\ncontract KittyInterface {\n    function getKitty(\n        uint256 _id\n    )\n        external\n        view\n        returns (\n            bool isGestating,\n            bool isReady,\n            uint256 cooldownIndex,\n            uint256 nextActionAt,\n            uint256 siringWithId,\n            uint256 birthTime,\n            uint256 matronId,\n            uint256 sireId,\n            uint256 generation,\n            uint256 genes\n        );\n}\n\ncontract ZombieFeeding is ZombieFactory {\n    KittyInterface kittyContract;\n\n    modifier onlyOwnerOf(uint _zombieId) {\n        require(msg.sender == zombieToOwner[_zombieId]);\n        _;\n    }\n\n    function setKittyContractAddress(address _address) external onlyOwner {\n        kittyContract = KittyInterface(_address);\n    }\n\n    function _triggerCooldown(Zombie storage _zombie) internal {\n        _zombie.readyTime = uint32(now + cooldownTime);\n    }\n\n    function _isReady(Zombie storage _zombie) internal view returns (bool) {\n        return (_zombie.readyTime <= now);\n    }\n\n    function feedAndMultiply(\n        uint _zombieId,\n        uint _targetDna,\n        string memory _species\n    ) internal onlyOwnerOf(_zombieId) {\n        Zombie storage myZombie = zombies[_zombieId];\n        require(_isReady(myZombie));\n        _targetDna = _targetDna % dnaModulus;\n        uint newDna = (myZombie.dna + _targetDna) / 2;\n        if (\n            keccak256(abi.encodePacked(_species)) ==\n            keccak256(abi.encodePacked(\"kitty\"))\n        ) {\n            newDna = newDna - (newDna % 100) + 99;\n        }\n        _createZombie(\"NoName\", newDna);\n        _triggerCooldown(myZombie);\n    }\n\n    function feedOnKitty(uint _zombieId, uint _kittyId) public {\n        uint kittyDna;\n        (, , , , , , , , , kittyDna) = kittyContract.getKitty(_kittyId);\n        feedAndMultiply(_zombieId, kittyDna, \"kitty\");\n    }\n}\n"
    },
    "contracts/zombiehelper.sol": {
      "content": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./zombiefeeding.sol\";\n\ncontract ZombieHelper is ZombieFeeding {\n    uint levelUpFee = 0.001 ether;\n\n    modifier aboveLevel(uint _level, uint _zombieId) {\n        require(zombies[_zombieId].level >= _level);\n        _;\n    }\n\n    function withdraw() external onlyOwner {\n        address payable _owner = address(uint160(owner()));\n        _owner.transfer(address(this).balance);\n    }\n\n    function setLevelUpFee(uint _fee) external onlyOwner {\n        levelUpFee = _fee;\n    }\n\n    function levelUp(uint _zombieId) external payable {\n        require(msg.value == levelUpFee);\n        zombies[_zombieId].level = zombies[_zombieId].level.add(1);\n    }\n\n    function changeName(\n        uint _zombieId,\n        string calldata _newName\n    ) external aboveLevel(2, _zombieId) onlyOwnerOf(_zombieId) {\n        zombies[_zombieId].name = _newName;\n    }\n\n    function changeDna(\n        uint _zombieId,\n        uint _newDna\n    ) external aboveLevel(20, _zombieId) onlyOwnerOf(_zombieId) {\n        zombies[_zombieId].dna = _newDna;\n    }\n\n    function getZombiesByOwner(\n        address _owner\n    ) external view returns (uint[] memory) {\n        uint[] memory result = new uint[](ownerZombieCount[_owner]);\n        uint counter = 0;\n        for (uint i = 0; i < zombies.length; i++) {\n            if (zombieToOwner[i] == _owner) {\n                result[counter] = i;\n                counter++;\n            }\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/zombieOwnership.sol": {
      "content": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./zombieattack.sol\";\nimport \"./erc721.sol\";\nimport \"./safemath.sol\";\n\n// @title Contract to give ownership for each zombies\n// @author Andrew Prasaath\n// @dev This contract uses ERC721 standard to give ownership\ncontract ZombieOwnership is ZombieAttack, ERC721 {\n    using SafeMath for uint256;\n\n    mapping(uint => address) zombieApprovals;\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return ownerZombieCount[_owner];\n    }\n\n    function ownerOf(uint256 _tokenId) external view returns (address) {\n        return zombieToOwner[_tokenId];\n    }\n\n    function _transfer(address _from, address _to, uint256 _tokenId) private {\n        ownerZombieCount[_to] = ownerZombieCount[_to].add(1);\n        ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1);\n        zombieToOwner[_tokenId] = _to;\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable {\n        require(\n            zombieToOwner[_tokenId] == msg.sender ||\n                zombieApprovals[_tokenId] == msg.sender\n        );\n        _transfer(_from, _to, _tokenId);\n    }\n\n    function approve(\n        address _approved,\n        uint256 _tokenId\n    ) external payable onlyOwnerOf(_tokenId) {\n        zombieApprovals[_tokenId] = _approved;\n        emit Approval(msg.sender, _approved, _tokenId);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}